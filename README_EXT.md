# Mongo DB: Расширенные возможности
Примечание. Все комментарии относятся к базе данных MongoDB v 7.0.4


## Индексирование: когда быстродействия не хватает
Подготовка базы данных
```bash
docker compose cp scripts/populate_phones.js mongo:/data/
docker compose exec -it mongo bash -c "mongosh -u root -p example /data/populate_phones.js --shell"
> use book
> populatePhones(800, 5550000, 5650000)
> populatePhones(855, 5550000, 5650000)
```
При создании любой коллекции Mongo автоматически строит индекс по полю `_id`. Эти индексы присутствуют в коллекции.  
`db.phones.getIndexes()` - показать все имеющиеся в базе данных индексы

Как правило, в запросах указывают и другие поля, помимо `_id`, поэтому по ним тоже следует построить индексы.  
Построим индекс со структурой B-дерева по полю `display`.  
Но поскольку наша цель – убедиться, что индекс действительно ускоряет работу, мы сначала выполним запрос без индекса. Чтобы получить сведения о том, как выполняется операция, мы воспользуемся методом `explain()`.  
```javascript
db.phones.find({ display: "+1 800-5650001" }).explain("executionStats")
```

### Построение индекса
Построить уникальный индекс по полю `display`, обнаруженные при построении дубликаты должны удаляться:
```javascript
db.phones.ensureIndex(
    { display : 1 },
    { unique : true, dropDups : true }
)
```

### Системное профилирование
`db.setProfilingLevel(2)` - установить уровень профилирования 2 (при уровне 2 сохраняется информация обо всех запросах, при уровне 1 – только о «медленных» запросах, исполнявшихся более 100 миллисекунд).  
В результате запроса создается новый объект в коллекции `system.profile`, которую можно читать, как любую другую:
```javascript
db.phones.find({ display : "+1 800-5650001" })
```
В поле `ts` хранится время начала запроса,  
в поле `command` – строка с описанием операции,  
в поле `millis` – затраченное время:  
```javascript
db.system.profile.find()
```
В промышленной системе индекс всегда следует строить в фоновом режиме, задавая параметр `{ background : 1 }`:
```javascript
db.phones.ensureIndex({ "components.area": 1 }, { background : 1 })
```
Для создания индекса над большой коллекцией может потребоваться много времени и системных ресурсов.  
Это следует учитывать и стараться строить индексы в периоды наименьшей нагрузки, в фоновом режиме и вручную, не применяя автоматизированные процедуры.  


## Агрегированные запросы
Операции агрегации обрабатываются множество документов и возвращают расчетный результат.
Примеры использования:  
- группировка по признаку;
- выполнение операций над сгруппированными данными;
- анализ изменения данных с течением времени.

Для выполнения агрегаций можно использовать:  
- **пайплайны агрегаций**: предпочтительные метод выполнения агрегаций
- **методы агрегаций целевого использования**: просты, но не имеют широких возможностей пайплайнов

### Методы агрегаций целевого использования
Посчитать число телефонов с номером меньше `5599999`:
```javascript
db.phones.countDocuments({"components.number": { $gt : 5599999 } })
```
Вернуть удовлетворяющие критерию уникальные значения (не полные документы), если хотя бы одно существует:
```javascript
db.phones.distinct(
    "components.number",
    { "components.number": { $lt: 5550005 } }
)
```

### Пайплайны агрегаций
Схема паплайна проста:
1. Пайплайн состоит из одного или нескольких этапов - например, этап может фильтровать документы, группировать, подсчитывать значения
2. Документы предыдущего этапа поступают на вход следующему этапу
3. Пайплайн может вернуть результаты для групп документов - сумма, среднее, максимум, минимум.

Подсчитать все номера больше `5 599 999`, и поместить их в отдельные группы по коду зоны:
```javascript
db.phones.aggregate([
    // Filter all component number greater than 5599999
    { $match: {"components.number": { $gt: 5599999}}},
    // Group by area. Add `count` field which is a sum of 1 for each grouped element 
    { $group: { _id: "$components.area", count: { $sum: 1 } }}
])
```

#### Замена MapReduce
В новых версиях MongoDB разработчики отказались от повсеместного использования механизма `map reduce` в пользу пайплайнов. Предлагается собирать пайаплайны с помощью предлагаемых этапов и операций.  
Коллекция этапов и операций довольно разнообразна, ниже - некоторые часто используемые варианты:  

| Этап | Описание |
| ---- | -------- |
| `$addFields` | Добавляет новые поля в каждый документ коллекции. Похоже на `$project`, `$addFields` преобразует каждый документ в потоке; конкретно, добавляет новые поля в выходной документ. В итоге на выходе документ содержит как поля исходного документа, а также добавленные поля.  |
| `$count` | Возвращает число документов на данном этапе пайплайна агрегации. |
| `$group` | Группипует входные документы по назначенному выражению-идентификатору и применяет аккумуляторное выражение(я), если они описаны, к каждой группе. Использует все входные документы и выводит один новый документ для каждой уникальной группы. Выходной документ содержит только поле идентификатора и, если определено(ы), поле(я) аккумуляторного(ых) варажения(ий). |
| `$limit` | Передает первые N входных документов в следующий этап пайплайна без изменений, где N - переданный лимит. Выводит один документ (для первых N документов) или ноль документов (для всех документов после первых N) для каждого входного документа. |
| `$match` | Фильтрует поток документов так, чтобы только подходящие по определенному условию документы прошли в следующий этап пайплайна. `$match` использует стандартные запросы MongoDB. Выводит один документ (прошел фильтр) или ноль документов (отфильтрован) для каждого входного документа. |
| `$merge` | Записывает документы в результате пайплайна в коллекцию. Этап может обновлять / добавлять / заменять / оставлять нетронутыми документы в результирующей коллекции, а также остановить операцию в случае ошибки. Этот этап должен быть последним в пайплайне. |
| `$out` | Записывает документы в результате пайплайна в коллекцию. Этот этап должен быть последним в пайплайне. |
| `$project` | Преобразует поток документов в пайплайне - добавляет новые поля / удаляет поля в каждый документ коллекции. Передает один документ на следующий этап для каждого входного документа. |
| `$set` | Добавляет новые поля в документ. Похоже на `$project`, `$set` преобразует каждый документ в потоке; конкретно, добавляет новые поля в выходной документ. В итоге на выходе документ содержит как поля исходного документа, а также добавленные поля. `$set` - алиас для этапа `$addFields`. |

Этапы подробно описаны в разделе на [оффициальном сайте MongoDB](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/).  
Там же описаны [доступные операторы агрегации](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). 

На случай если всё же нужно использовать пользовательскую функцию существует оператор `$function`.  
Cтандартный способ преобразования механизма _Map-Reduce_ в агрегацию:
- с помощью `$project` определить поля в результируещем документе (как после _Map-Reduce_). Расчетные поля можно предварительно доавить с помощью `$addFields`;
- через `$unwind` преобразовать вложенные списки в одном документе в список документов с одним элементом этого списка;
- определить в `$group` аккумуляторную функцию (часть _Reduce_)
- назначить результирующую коллекцию - куда сохранить результаты - с помощью `$merge`.

В примере ниже:
- `$project` определяет ключ группировки как документ, состоящий из двух полей: поле-массив уникальных цифр в номере телефона и код страны;
- `$unwind` присутсвует для примера;
- `$group` использует подготовленный ключ и считает сумму для вложенного поля `emits.count` внутри группировки по ключу;
-  `$merge` записывает результат в `phones.report` так, что новые результаты добавляются, а дубликаты по `_id` перезаписываются.



```javascript
db.phones.aggregate([
    {
        $project:
        {
            emits: {
                key: {
                    digits: {
                        $function: {
                            body: function (number) {
                                number = number + "";
                                var
                                    seen = [],
                                    result = [],
                                    i = number.length;
                                while (i--) {
                                    seen[+number[i]] = 1;
                                }
                                for (i = 0; i < 10; i++) {
                                    if (seen[i]) {
                                        result[result.length] = i;
                                    }
                                }
                                return result;
                            },
                            args: ["$components.number"],
                            lang: "js"
                        }
                    },
                    country: "$components.country"
                },
                count: {"$literal" : 1}
            }
        }
    },
    { $unwind: "$emits" },
    {
        $group: {
            _id: "$emits.key",
            value: { $sum: "$emits.count" }
        },
    },
    { $merge: { into: "phones.report", on: "_id", whenMatched: "replace", whenNotMatched: "insert" } }
])
```
