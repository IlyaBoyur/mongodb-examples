# Mongo DB: Расширенные возможности
Примечание. Все комментарии относятся к базе данных MongoDB v 7.0.4

## Индексирование, профилирование, агрегации
### Индексирование: когда быстродействия не хватает
Подготовка базы данных
```bash
docker compose cp scripts/populate_phones.js mongo:/data/
docker compose exec -it mongo bash -c "mongosh -u root -p example /data/populate_phones.js --shell"
> use book
> populatePhones(800, 5550000, 5650000)
> populatePhones(855, 5550000, 5650000)
```
При создании любой коллекции Mongo автоматически строит индекс по полю `_id`. Эти индексы присутствуют в коллекции.  
`db.phones.getIndexes()` - показать все имеющиеся в базе данных индексы

Как правило, в запросах указывают и другие поля, помимо `_id`, поэтому по ним тоже следует построить индексы.  
Построим индекс со структурой B-дерева по полю `display`.  
Но поскольку наша цель – убедиться, что индекс действительно ускоряет работу, мы сначала выполним запрос без индекса. Чтобы получить сведения о том, как выполняется операция, мы воспользуемся методом `explain()`.  
```javascript
db.phones.find({ display: "+1 800-5650001" }).explain("executionStats")
```

#### Построение индекса
Построить уникальный индекс по полю `display`, обнаруженные при построении дубликаты должны удаляться:
```javascript
db.phones.ensureIndex(
    { display : 1 },
    { unique : true, dropDups : true }
)
```

### Системное профилирование
`db.setProfilingLevel(2)` - установить уровень профилирования 2 (при уровне 2 сохраняется информация обо всех запросах, при уровне 1 – только о «медленных» запросах, исполнявшихся более 100 миллисекунд).  
В результате запроса создается новый объект в коллекции `system.profile`, которую можно читать, как любую другую:
```javascript
db.phones.find({ display : "+1 800-5650001" })
```
В поле `ts` хранится время начала запроса,  
в поле `command` – строка с описанием операции,  
в поле `millis` – затраченное время:  
```javascript
db.system.profile.find()
```
В промышленной системе индекс всегда следует строить в фоновом режиме, задавая параметр `{ background : 1 }`:
```javascript
db.phones.ensureIndex({ "components.area": 1 }, { background : 1 })
```
Для создания индекса над большой коллекцией может потребоваться много времени и системных ресурсов.  
Это следует учитывать и стараться строить индексы в периоды наименьшей нагрузки, в фоновом режиме и вручную, не применяя автоматизированные процедуры.  


### Агрегированные запросы
Операции агрегации обрабатываются множество документов и возвращают расчетный результат.
Примеры использования:  
- группировка по признаку;
- выполнение операций над сгруппированными данными;
- анализ изменения данных с течением времени.

Для выполнения агрегаций можно использовать:  
- **пайплайны агрегаций**: предпочтительные метод выполнения агрегаций
- **методы агрегаций целевого использования**: просты, но не имеют широких возможностей пайплайнов

#### Методы агрегаций целевого использования
Посчитать число телефонов с номером меньше `5599999`:
```javascript
db.phones.countDocuments({"components.number": { $gt : 5599999 } })
```
Вернуть удовлетворяющие критерию уникальные значения (не полные документы), если хотя бы одно существует:
```javascript
db.phones.distinct(
    "components.number",
    { "components.number": { $lt: 5550005 } }
)
```

#### Пайплайны агрегаций
Схема паплайна проста:
1. Пайплайн состоит из одного или нескольких этапов - например, этап может фильтровать документы, группировать, подсчитывать значения
2. Документы предыдущего этапа поступают на вход следующему этапу
3. Пайплайн может вернуть результаты для групп документов - сумма, среднее, максимум, минимум.

Подсчитать все номера больше `5 599 999`, и поместить их в отдельные группы по коду зоны:
```javascript
db.phones.aggregate([
    // Filter all component number greater than 5599999
    { $match: {"components.number": { $gt: 5599999}}},
    // Group by area. Add `count` field which is a sum of 1 for each grouped element 
    { $group: { _id: "$components.area", count: { $sum: 1 } }}
])
```

##### Замена MapReduce
В новых версиях MongoDB разработчики отказались от повсеместного использования механизма `map reduce` в пользу пайплайнов. Предлагается собирать пайаплайны с помощью предлагаемых этапов и операций.  
Коллекция этапов и операций довольно разнообразна, ниже - некоторые часто используемые варианты:  

| Этап | Описание |
| ---- | -------- |
| `$addFields` | Добавляет новые поля в каждый документ коллекции. Похоже на `$project`, `$addFields` преобразует каждый документ в потоке; конкретно, добавляет новые поля в выходной документ. В итоге на выходе документ содержит как поля исходного документа, а также добавленные поля.  |
| `$count` | Возвращает число документов на данном этапе пайплайна агрегации. |
| `$group` | Группипует входные документы по назначенному выражению-идентификатору и применяет аккумуляторное выражение(я), если они описаны, к каждой группе. Использует все входные документы и выводит один новый документ для каждой уникальной группы. Выходной документ содержит только поле идентификатора и, если определено(ы), поле(я) аккумуляторного(ых) варажения(ий). |
| `$limit` | Передает первые N входных документов в следующий этап пайплайна без изменений, где N - переданный лимит. Выводит один документ (для первых N документов) или ноль документов (для всех документов после первых N) для каждого входного документа. |
| `$match` | Фильтрует поток документов так, чтобы только подходящие по определенному условию документы прошли в следующий этап пайплайна. `$match` использует стандартные запросы MongoDB. Выводит один документ (прошел фильтр) или ноль документов (отфильтрован) для каждого входного документа. |
| `$merge` | Записывает документы в результате пайплайна в коллекцию. Этап может обновлять / добавлять / заменять / оставлять нетронутыми документы в результирующей коллекции, а также остановить операцию в случае ошибки. Этот этап должен быть последним в пайплайне. |
| `$out` | Записывает документы в результате пайплайна в коллекцию. Этот этап должен быть последним в пайплайне. |
| `$project` | Преобразует поток документов в пайплайне - добавляет новые поля / удаляет поля в каждый документ коллекции. Передает один документ на следующий этап для каждого входного документа. |
| `$set` | Добавляет новые поля в документ. Похоже на `$project`, `$set` преобразует каждый документ в потоке; конкретно, добавляет новые поля в выходной документ. В итоге на выходе документ содержит как поля исходного документа, а также добавленные поля. `$set` - алиас для этапа `$addFields`. |

Этапы подробно описаны в разделе на [оффициальном сайте MongoDB](https://www.mongodb.com/docs/manual/reference/operator/aggregation-pipeline/).  
Там же описаны [доступные операторы агрегации](https://www.mongodb.com/docs/manual/reference/operator/aggregation/). 

На случай если всё же нужно использовать пользовательскую функцию существует оператор `$function`.  
Cтандартный способ преобразования механизма _Map-Reduce_ в агрегацию:
- с помощью `$project` определить поля в результируещем документе (как после _Map-Reduce_). Расчетные поля можно предварительно доавить с помощью `$addFields`;
- через `$unwind` преобразовать вложенные списки в одном документе в список документов с одним элементом этого списка;
- определить в `$group` аккумуляторную функцию (часть _Reduce_)
- назначить результирующую коллекцию - куда сохранить результаты - с помощью `$merge`.

В примере ниже:
- `$project` определяет ключ группировки как документ, состоящий из двух полей: поле-массив уникальных цифр в номере телефона и код страны;
- `$unwind` присутсвует для примера;
- `$group` использует подготовленный ключ и считает сумму для вложенного поля `emits.count` внутри группировки по ключу;
-  `$merge` записывает результат в `phones.report` так, что новые результаты добавляются, а дубликаты по `_id` перезаписываются.

```javascript
db.phones.aggregate([
    {
        $project:
        {
            emits: {
                key: {
                    digits: {
                        $function: {
                            body: function (number) {
                                number = number + "";
                                var
                                    seen = [],
                                    result = [],
                                    i = number.length;
                                while (i--) {
                                    seen[+number[i]] = 1;
                                }
                                for (i = 0; i < 10; i++) {
                                    if (seen[i]) {
                                        result[result.length] = i;
                                    }
                                }
                                return result;
                            },
                            args: ["$components.number"],
                            lang: "js"
                        }
                    },
                    country: "$components.country"
                },
                count: {"$literal" : 1}
            }
        }
    },
    { $unwind: "$emits" },
    {
        $group: {
            _id: "$emits.key",
            value: { $sum: "$emits.count" }
        },
    },
    { $merge: { into: "phones.report", on: "_id", whenMatched: "replace", whenNotMatched: "insert" } }
])
```


## Наборы реплик, сегментирование, пространственные данные и GridFS
Уникальная особенность документных баз данных заключается в способности эффективно обрабатывать бессхемные документы с произвольным уровнем вложенности. А конкретно Mongo отличается умением масштабироваться на несколько серверов путем **репликации** (копирования данных на другие серверы) или **сегментирования коллекций** (разбиения коллекции на части), а также умением параллельно выполнять запросы. То и другое повышает доступность.


### Реплики
Для запуска сервера в режиме реплики в команду передается флаг `--replSet`:
```bash
$ /usr/bin/mongod --replSet my-replica-set
```
Развертывание и конфигурирование кластера через `docker-compose`:
```bash
cd replicas
./replica-init.sh
```

Ниже представлено описание этапов.
1) Развертывание кластера
```bash
cd replicas
docker compose -f docker-compose-replicas.yml up -d --remove-orphans
```

2) Инициализация реплик в кластере
```bash
docker compose -f docker-compose-replicas.yml exec -it mongo1 mongosh --eval "rs.initiate({
 _id: \"my-replica-set\",
 members: [
   {_id: 0, host: \"mongo1\"},
   {_id: 1, host: \"mongo2\"},
   {_id: 2, host: \"mongo3\"}
 ]
})"
```

3) Проверка реплик в кластере
```bash
docker compose -f docker-compose-replicas.yml  exec -it mongo1 mongosh --eval "rs.status()"
```
Здесь мы воспользовались новым объектом `rs` (_replica set_ – набор реплик). У него, как и любого другого объекта, имеется метод `help()`.

#### Как ведут себя реплики
Определить главную реплику поможет команда `db.isMaster()`, а также подпись в командной строке `mongosh`:
```bash
docker compose -f docker-compose-replicas.yml  exec -it mongo3 mongosh
```
```javascript
// логи инициализации консоли
my-replica-set [direct: primary] test>
```
Вставляем данные в главном узле кластера:
```javascript
my-replica-set [direct: primary] test> db.echo.insertOne({ say : "HELLO!" })
```
Останавливаем главную реплику. В результате главной станет одна из оставшихся реплик:
```bash
docker compose -f docker-compose-replicas.yml stop mongo3
docker compose -f docker-compose-replicas.yml  exec -it mongo1 mongosh
```
```javascript
// логи инициализации консоли
my-replica-set [direct: primary] test>
```
Находим новую главную реплику и читаем через неё введенные ранее данные:
```javascript
my-replica-set [direct: primary] test> db.echo.find()
...
[ { _id: ObjectId('6599189f759162d5a6a765fe'), say: 'HELLO!' } ]
```
Попытка вставить данные в консоли реплики привидет к ошибке:
```bash
docker compose -f docker-compose-replicas.yml  exec -it mongo2 mongosh
```
```javascript
// логи инициализации консоли
my-replica-set [direct: secondary test> db.echo.insertOne({ say : "is this thing on?" })
...
MongoServerError: not primary
```

Таким образом, в каждом наборе реплик существует только один главный узел, и взаимодействовать (CRUD) нужно именно с ним. Это шлюз ко всему набору. 


#### Проблема четного числа узлов
Если главный сервер недоступен, то на его роль выбирается один из оставшихся, и он продолжает обслуживать запросы. Однако сервер может оказаться недоступен не только в результате выхода из строя. Иногда пропадает сетевое соединение между узлами. В таком случае Mongo заявляет, что **сеть состоит из большинства узлов, все еще способных видеть друг друга**.

Предположим, что в результате потери связности образовалось два сегмента из двух узлов. В одном из них по-прежнему находится исходный главный узел, но поскольку он не видит явного большинства сети, то снимает с себя обязанности главного сервера. Но и в другом фрагменте выбрать главный узел невозможно, потому что _нет связи с явным большинством узлов_. Ни тот, ни другой набор не могут обслуживать запросы, и **вся система останавливается**.

MongoDB подходит к конфликтам между несколькими главными узлами просто – не допускает их вовсе.


#### Сегментирование (Шардирование)
Вместо того чтобы хранить всю коллекцию на одном сервере, она разбивается на части (иными словами, сегментируется), которые размещаются на нескольких серверах.
Развертывание и конфигурирование кластера с шардированием через `docker-compose`:
```bash
$ cd shards
$ ./shards-init.sh
```
Ниже приводятся детали запуска сервера mongo без учета окружения.  

Для запуска сервера в режиме сегментирования в команду передается флаг `--shardsvr`:
```bash
$ mongod --shardsvr --dbpath ./mongo4 --port 27014
$ mongod --shardsvr --dbpath ./mongo5 --port 27015
```
Примечание. Порт указан явно, т.к. по умолчанию сервер с шардированием запускается на порте 27018, что не всегда удобно.

Предположим, что мы создали таблицу для хранения названий городов в алфавитном порядке. Необходимо как-то сообщить, что названия, начинающиеся с букв от A до N (к примеру) должны храниться на сервере `mongo4`, а начинающиеся с букв от O до Z – на сервере `mongo5`. В Mongo для этой цели создается **конфигурационный сервер** (обычный экземпляр `mongod`, запущенный со специальным флагом), который учитывает, какой сервер (`mongo4` или `mongo5`) какие значения хранит.
```bash
$ mongod --configsvr --dbpath ./mongoconfig --port 27016
```
Примечание. Порт указан явно, т.к. по умолчанию конфигурационный сервер запускается на порте 27019, что не всегда удобно.

Наконец, нам необходим еще четвертый сервер, `mongos`, являющийся единственной точкой входа для клиентов. Сервер `mongos` подключается к конфигурационному серверу (назовем его `mongoconfig`) для получения информации о сегментировании. Запустим его на порту `27020`.
О местонахождении конфигурационного сервера (доменное имя:номер порта) `mongos` узнает благодаря флагу `--configdb`.
```bash
mongos --configdb localhost:27016 --port 27020
```

##### mongos и mongoconfig
Может возникнуть вопрос, зачем Mongo разделяет роли _конфигурация_ и _точка входа_ (`mongos`). Связано это с тем, что в производственных системах эти процессы обычно запускаются на физически различных серверах. Конфигурационный сервер (который сам реплицируется) управляет информацией о сегментировании в интересах других сегментированных серверов, тогда как `mongos` обычно запускается на той же машине, где работает сервер приложений, чтобы клиенты легко могли к нему подключаться (не думая о том, где находятся конкретные сегменты).  
Интересно, что `mongos` является облегченной версией полнофункционального сервера `mongod`.


##### Настройка сегментов
1) Подключиться к консоли `mongosh` сервера `mongos` и перейти в базу `admin`:
```bash
$ docker compose -f docker-compose-shards.yml exec -it mongos mongosh

Current Mongosh Log ID: 6599920aa69f5de5a5c5ca82
Connecting to:          mongodb://127.0.0.1:27017/?directConnection=true&serverSelectionTimeoutMS=2000&appName=mongosh+2.1.1
...
[direct: mongos] test> use admin
switched to db admin
[direct: mongos] admin> 
```
2) Добавить серверы-реплики с шардированием в кластер:
```bash
sh.addShard("<replSetName>/s1-mongo1.example.net:27018,s1-mongo2.example.net:27018,s1-mongo3.example.net:27018")
```
Пример:
```bash
[direct: mongos] admin> sh.addShard("shard-set/mongo4:27018,mongo5:27018")

{
  shardAdded: 'shard-set',
  ok: 1,
...
```
2) Указать базу данных, подлежащую сегментированию коллекцию и поле, по которому сегментировать:
```bash
sh.shardCollection("<database>.<collection>", { <shard key field> : 1, ... } )
```
Пример:
```bash
[direct: mongos] admin> sh.shardCollection("test.cities", {name : 1} )

{
  collectionsharded: 'test.cities',
  ok: 1,
...
```
3) Загрузить данные для сегментирования:
```bash
mongoimport <options> <connection-string> <file> 
mongosh <options> <javascript-file-with-data-insertions> 
```
Пример (будет использована база данных по умолчанию - `test`):
```bash
$ cd shards
$ docker compose -f docker-compose-shards.yml cp mongo_cities1000.js mongos:/tmp
$ docker compose -f docker-compose-shards.yml exec -it mongos bash -c "mongosh < /tmp/mongo_cities1000.js"
```


#### Пространственные запросы

Создать 2D индекс
```javascript
db.cities.ensureIndex({ location : "2d" })
```

Выполнить поиск с использованием индекса
```javascript
db.cities.find({ location : { $near : [45.52, -122.67] } }).limit(5)
```

Этап агрегации `geoNear()` позволяет задать минимальное, максимальное расстояние, предварительный фильтр документов, способ вычисления расстояния (сферический (`2dsphere`) или декартовый(`2d`)), а также добавлять информацию о расстоянии и координатах в выходные документы.
```javascript
db.cities.aggregate([
    {
        $geoNear: {
            near: [45.52, -122.67],
            distanceField: "dist.calculated",
            maxDistance: 5,
            query: {},
            includeLocs: "dist.location",
            spherical: false
        }
    },
    { $limit: 5 }
])
```

#### GridFS
GridFS - собственная распределенная файловая система MongoDB.  
Получить список файлов:
```bash
mongofiles -h localhost:27017 list
```
Загрузить файл:
```bash
touch /tmp/my_file.txt
mongofiles -h localhost:27017 put /tmp/my_file.txt
```
Посмотреть, в каких коллекциях Mongo хранит данные:
```bash
$ mongosh --eval "show collections"
Current Mongosh Log ID: 6599c3e4e4ed52ed327cd9a1
...
fs.chunks
fs.files
```
| Сильные стороны Mongo | Слабые стороны Mongo |
| --- | --- |
| Cпособность обрабатывать гигантские массивы данных (и огромный поток запросов) за счет репликации и горизонтального масштабирования. | Mongo поощряет денормализацию схемы. |
| Предлагает весьма гибкую модель данных, так как не нужно заранее определять схему. | Возможность вставки в любую коллекцию значения произвольного типа вызывает опасения. |
| Данные могут быть вложенными. | Единственная опечатка может стать причиной многочасовых мучений, если вы не догадаетесь искать причину в именах полей и коллекций. |
| При проектировании MongoDB закладывалась простота использования. | Гибкость Mongo – не такое уж большое преимущество, если модель данных уже достаточно зрелая и давно зафиксирована. |
| Сходство между командами Mongo и некоторыми концепциями баз данных на основе SQL. | Настройка кластера Mongo подразумевает предварительное планирование.|
 